- 令`dp[i][v](1<=i<=n, 0<=v<=V)`表示前i件物品恰好装入容量为v的背包中所能获得的最大价值。  
- 状态转移方程：  
  ```c++
  max{
      dp[i-1][v],//不放第i件物品
      dp[i-1][v-w[i]] + c[i],//放第i件物品
  }
  ```

- 边界：`dp[0][v] = 0(0<=v<=V)`
- 代码：
  ```c++
  for (int i = 1; i <= n; i++) {
      for (int v = w[i]; v <= V; v++) {
          dp[i][v] = max(dp[i-1][v],
                         dp[i-1][v-w[i]] + c[i])
      }
  }
  ```

- 使用滚动数组法给dp矩阵降维
  ```c++
  dp[v] = max{
      dp[v],
      dp[v-w[i]] + c[i],
      //重点在于！！！一定要逆序访问v
  }
  ```
- 代码
  ```c++
  for (int i = 1; i <= n; i++) {
      for (int v = V; v >= w[i]; v--) {
          dp[v] = max(dp[v],
                      dp[v-w[i]] + c[i]);
      }
  }
  ```
- 如果是用二维数组存放，v的枚举是顺序还是逆序都无所谓；如果使用一维数组存放，则v的枚举必须是逆序